package main

import (
	"bytes"
	"encoding/base64"
	"io"
	"fmt"
	"github.com/makiuchi-d/gozxing"
	"github.com/makiuchi-d/gozxing/qrcode"
	"image"
	"image/draw"
	"image/png"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

func SaveImage(b string) {
	unbased, err := base64.StdEncoding.DecodeString(b)
	if err != nil {
		panic("Cannot decode b64")
	}

	r := bytes.NewReader(unbased)
	im, err := png.Decode(r)
	if err != nil {
		panic("Bad png")
	}

	f, err := os.OpenFile("example.png", os.O_WRONLY|os.O_CREATE, 0777)
	if err != nil {
		panic("Cannot open file")
	}

	png.Encode(f, im)
}

func FixImage() {
	image1, _ := os.Open("example.png")
	defer image1.Close()
	first, _ := png.Decode(image1)

	image2, _ := os.Open("add.png")
	defer image2.Close()
	second, _ := png.Decode(image2)

	offset := image.Pt(0, 0)
	b := first.Bounds()
	image3 := image.NewRGBA(b)
	draw.Draw(image3, b, first, image.ZP, draw.Src)
	draw.Draw(image3, second.Bounds().Add(offset), second, image.ZP, draw.Over)

	third, _ := os.Create("tmp_qrcode.png")
	defer third.Close()
	png.Encode(third, image3)

}

func QRread() string  {
// open and decode image file
file, _ := os.Open("tmp_qrcode.png")
img, _ := png.Decode(file)

// prepare BinaryBitmap
bmp, _ := gozxing.NewBinaryBitmapFromImage(img)

// decode image
qrReader := qrcode.NewQRCodeReader()
result, _ := qrReader.Decode(bmp, nil)



old := os.Stdout // keep backup of the real stdout
r, w, _ := os.Pipe()
os.Stdout = w

fmt.Println(result)

outC := make(chan string)
// copy the output in a separate goroutine so printing can't block indefinitely
go func() {
	var buf bytes.Buffer
	io.Copy(&buf, r)
	outC <- buf.String()
}()

// back to normal state
w.Close()
os.Stdout = old // restoring the real stdout
out := <-outC

// reading our temp stdout
// fmt.Println("previous output:")
return out
}

func main() {

	for i := 1; i <= 100; i++ {
		url := "http://challenge01.root-me.org/programmation/ch7/"
		req, _ := http.NewRequest("GET", url, nil)
		res, _ := http.DefaultClient.Do(req)
		defer res.Body.Close()
	
		var mycookie string
		for _, cookie := range res.Cookies() {
			mycookie = cookie.Value
		}
	
		body, _ := ioutil.ReadAll(res.Body)
		resp := string(body)
		arr := strings.Split(resp, ",")
		resp = arr[1]
		b := ""
	
		for _, j := range resp {
			if j != '"' {
				b += string(j)
			}
			if j == '"' {
				break
			}
		}
	
		SaveImage(b)
		FixImage()
		QRread()
		text := QRread()
	
		arr1 := strings.Split(text, " ")
	
		result := arr1[3]
	// result := ""
	// 	for _, j := range result1 {
	// 		if j != '/' {
	// 			result += string(j)
	// 		}
	// 	}
	// 	arr2 := strings.Split(result, "_")
	
	// 	result = arr2[1]
	
	
		if 0 < 1 {
			url := "http://challenge01.root-me.org/programmation/ch7/" 
			postData := "metu=" + result
			fmt.Println(postData)
			req, _ := http.NewRequest("POST", url, bytes.NewBufferString(postData))
			req.Header.Set("Cookie", "PHPSESSID="+mycookie)
			req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
			res, _ := http.DefaultClient.Do(req)
			defer res.Body.Close()
			body, _ := ioutil.ReadAll(res.Body)
			resp := string(body)
			// if !strings.Contains(resp, "retente ta chance") {
				fmt.Println("LOOKS LIKE I FOUND SOMETHING!", resp)
			// 	os.Exit(1)
			// }
	}
	}
	
}
